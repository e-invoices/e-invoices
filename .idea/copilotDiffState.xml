<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# FastAPI + React Starter Kit&#10;&#10;Kick-start fullstack projects with a FastAPI backend, room for a React frontend (drop code into `frontend/`), PostgreSQL via Docker Compose, opinionated tooling, and ready-to-run developer workflows.&#10;&#10;- Docker-first workflow: `docker compose` spins up the API, Postgres, and leaves room for a React frontend container.&#10;- Database layer: PostgreSQL plus Alembic migrations (see `backend/alembic`) and async SQLAlchemy sessions out of the box.&#10;- Quality gates: pytest suite (selective pre-commit hook) and formatting via Black/isort/Ruff to keep diffs tidy.&#10;&#10;## Setup&#10;&#10;### Create &amp; activate virtual environment&#10;```powershell&#10;cd PythonProject\backend&#10;python -m venv .venv&#10;.\.venv\Scripts\Activate.ps1&#10;pip install -r requirements-dev.txt&#10;```&#10;&#10;### Run Docker services&#10;If you start for the first time:&#10;```powershell&#10;docker compose up -d --build&#10;```&#10;Else:&#10;```powershell&#10;docker compose up -d&#10;```&#10;&#10;### Apply database migrations (inside backend container)&#10;```powershell&#10;cd PythonProject&#10;docker compose exec backend /bin/bash&#10;alembic revision --autogenerate -m &quot;init schema&quot;&#10;alembic upgrade head&#10;exit&#10;```&#10;&#10;### Run the app locally (optional)&#10;```powershell&#10;cd PythonProject\backend&#10;.\.venv\Scripts\Activate.ps1&#10;uvicorn app.main:app --reload&#10;```&#10;&#10;Visit `http://localhost:8000/api/v1/health/` to verify the service is responding.&#10;&#10;### Environment configuration&#10;Copy `backend/.env.example` to `backend/.env` (and adjust secrets), then ensure Docker uses it by keeping the file in place. For container-specific overrides, duplicate it as `.env.docker` and update `DATABASE_URL=postgresql+psycopg2://postgres:postgres@db:5432/backend_db`.&#10;&#10;### Run tests (inside backend container)&#10;```powershell&#10;cd PythonProject&#10;docker compose exec backend /bin/bash&#10;pytest&#10;exit&#10;```&#10;&#10;### Run tests (local virtual environment)&#10;```powershell&#10;cd PythonProject\backend&#10;.\.venv\Scripts\Activate.ps1&#10;pytest&#10;```&#10;&#10;### Git hooks: format + lint + tests&#10;The repo ships with a `.pre-commit-config.yaml` that runs formatting (Black/isort/Ruff) on every commit and executes `pytest backend/tests` before a push.&#10;&#10;```powershell&#10;pre-commit install&#10;pre-commit run --all-files  # optional warm-up&#10;```&#10;Pre-commit executes a custom helper (`scripts/run_changed_pytest.py`) so only touched test modules run under pytest alongside the formatting hooks.&#10;&#10;&#10;## Environments &amp; Docker targets&#10;Set `APP_ENV` to `development`, `staging`, or `production` to pick the matching Docker multi-stage target and application mode. The value is also loaded from `backend/.env` inside containers.&#10;&#10;```powershell&#10;# development (default)&#10;docker compose up -d&#10;&#10;# staging build/run&#10;docker compose up -d --build --pull always &#10;&#10;# production build/run&#10;docker compose up -d --build --pull always &#10;```&#10;&#10;## API quick reference&#10;- `GET /api/v1/health/` – service heartbeat (returns status/timestamp)&#10;- `POST /api/v1/users/` – create user (requires JSON payload matching `UserCreate`)&#10;- `GET /api/v1/users/` – list users&#10;- `POST /api/v1/auth/register` – register user &amp; receive JWT&#10;- `POST /api/v1/auth/token` – obtain JWT via credentials form&#10;" />
              <option name="updatedContent" value="# FastAPI + React Starter Kit&#10;&#10;Kick-start fullstack projects with a FastAPI backend, room for a React frontend (drop code into `frontend/`), PostgreSQL via Docker Compose, opinionated tooling, and ready-to-run developer workflows.&#10;&#10;- Docker-first workflow: `docker compose` spins up the API, Postgres, and leaves room for a React frontend container.&#10;- Database layer: PostgreSQL plus Alembic migrations (see `backend/alembic`) and async SQLAlchemy sessions out of the box.&#10;- Quality gates: pytest suite (selective pre-commit hook) and formatting via Black/isort/Ruff to keep diffs tidy.&#10;&#10;## Setup&#10;&#10;### Create &amp; activate virtual environment&#10;```powershell&#10;cd PythonProject\backend&#10;python -m venv .venv&#10;.\.venv\Scripts\Activate.ps1&#10;pip install -r requirements-dev.txt&#10;```&#10;&#10;### Run Docker services&#10;If you start for the first time:&#10;```powershell&#10;docker compose up -d --build&#10;```&#10;Else:&#10;```powershell&#10;docker compose up -d&#10;```&#10;&#10;### Apply database migrations (inside backend container)&#10;```powershell&#10;cd PythonProject&#10;docker compose exec backend /bin/bash&#10;alembic revision --autogenerate -m &quot;init schema&quot;&#10;alembic upgrade head&#10;exit&#10;```&#10;&#10;### Run the app locally (optional)&#10;```powershell&#10;cd PythonProject\backend&#10;.\.venv\Scripts\Activate.ps1&#10;uvicorn app.main:app --reload&#10;```&#10;&#10;Visit `http://localhost:8000/api/v1/health/` to verify the service is responding.&#10;&#10;### Environment configuration&#10;Copy `backend/.env.example` to `backend/.env` (and adjust secrets), then ensure Docker uses it by keeping the file in place. For container-specific overrides, duplicate it as `.env.docker` and update `DATABASE_URL=postgresql+psycopg2://postgres:postgres@db:5432/backend_db`.&#10;&#10;### Run tests (inside backend container)&#10;```powershell&#10;cd PythonProject&#10;docker compose exec backend /bin/bash&#10;pytest&#10;exit&#10;```&#10;&#10;### Run tests (local virtual environment)&#10;```powershell&#10;cd PythonProject\backend&#10;.\.venv\Scripts\Activate.ps1&#10;pytest&#10;```&#10;&#10;### Git hooks: format + lint + tests&#10;The repo ships with a `.pre-commit-config.yaml` that runs formatting (Black/isort/Ruff) on every commit and executes `pytest backend/tests` before a push.&#10;&#10;```powershell&#10;pre-commit install&#10;pre-commit run --all-files  # optional warm-up&#10;```&#10;Pre-commit executes a custom helper (`scripts/run_changed_pytest.py`) so only touched test modules run under pytest alongside the formatting hooks.&#10;&#10;&#10;## Environments &amp; Docker targets&#10;Set `APP_ENV` to `development`, `staging`, or `production` to pick the matching Docker multi-stage target and application mode. The value is also loaded from `backend/.env` inside containers.&#10;&#10;```powershell&#10;# development (default)&#10;docker compose up -d&#10;&#10;# staging build/run&#10;docker compose up -d --build --pull always &#10;&#10;# production build/run&#10;docker compose up -d --build --pull always &#10;```&#10;&#10;## API quick reference&#10;- `GET /api/v1/health/` – service heartbeat (returns status/timestamp)&#10;- `POST /api/v1/users/` – create user (requires JSON payload matching `UserCreate`)&#10;- `GET /api/v1/users/` – list users&#10;- `POST /api/v1/auth/register` – register user &amp; receive JWT&#10;- `POST /api/v1/auth/token` – obtain JWT via credentials form" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/.env.example" />
              <option name="originalContent" value="APP_NAME=Backend Service&#10;ENVIRONMENT=development&#10;API_V1_PREFIX=/api/v1&#10;DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/backend_db&#10;POSTGRES_SERVER=localhost&#10;POSTGRES_PORT=5432&#10;POSTGRES_DB=backend_db&#10;POSTGRES_USER=postgres&#10;POSTGRES_PASSWORD=postgres&#10;REDIS_URL=redis://localhost:6379/0&#10;SECRET_KEY=please-change-me&#10;ACCESS_TOKEN_EXPIRE_MINUTES=30&#10;JWT_ALGORITHM=HS256&#10;EMAIL_FROM=noreply@example.com&#10;SMTP_HOST=localhost&#10;SMTP_PORT=587&#10;SMTP_USER=postgres&#10;SMTP_PASSWORD=postgres" />
              <option name="updatedContent" value="APP_NAME=Backend Service&#13;&#10;ENVIRONMENT=development&#13;&#10;API_V1_PREFIX=/api/v1&#13;&#10;DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/backend_db&#13;&#10;POSTGRES_SERVER=localhost&#13;&#10;POSTGRES_PORT=5432&#13;&#10;POSTGRES_DB=backend_db&#13;&#10;POSTGRES_USER=postgres&#13;&#10;POSTGRES_PASSWORD=postgres&#13;&#10;REDIS_URL=redis://localhost:6379/0&#13;&#10;SECRET_KEY=please-change-me&#13;&#10;ACCESS_TOKEN_EXPIRE_MINUTES=30&#13;&#10;JWT_ALGORITHM=HS256&#13;&#10;EMAIL_FROM=noreply@example.com&#13;&#10;SMTP_HOST=localhost&#13;&#10;SMTP_PORT=587&#13;&#10;SMTP_USER=postgres&#13;&#10;SMTP_PASSWORD=postgres" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/db/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/db/base.py" />
              <option name="originalContent" value="from sqlalchemy.orm import DeclarativeBase&#10;&#10;&#10;class Base(DeclarativeBase):&#10;    &quot;&quot;&quot;Base class for all ORM models.&quot;&quot;&quot;&#10;    pass&#10;" />
              <option name="updatedContent" value="from sqlalchemy.orm import DeclarativeBase&#10;&#10;&#10;class Base(DeclarativeBase):&#10;    &quot;&quot;&quot;Base class for all ORM models.&quot;&quot;&quot;&#10;    pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/services/auth.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/services/auth.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from typing import Optional, Any, Coroutine&#10;&#10;from fastapi import HTTPException, status&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;&#10;from app.core.security import create_access_token, get_password_hash, verify_password&#10;from app.models import user as user_models&#10;from app.models.schemas import Token, UserCreate&#10;from app.services.users import UserService&#10;from app.models.schemas import UserRead&#10;&#10;&#10;class AuthService:&#10;    def __init__(self, session: AsyncSession) -&gt; None:&#10;        self.user_service = UserService(session)&#10;&#10;    async def authenticate_user(self, email: str, password: str) -&gt; user_models.User:&#10;        user = await self.user_service.get_by_email(email)&#10;        if not user or not verify_password(password, user.hashed_password):&#10;            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Invalid credentials&quot;)&#10;        return user&#10;&#10;    async def register_user(self, payload: UserCreate) -&gt; UserRead:&#10;        user = await self.user_service.get_by_email(payload.email)&#10;        if user:&#10;            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=&quot;Email already registered&quot;)&#10;        hashed_password = get_password_hash(payload.password)&#10;        return await self.user_service.create_user(payload, hashed_password=hashed_password)&#10;&#10;    def generate_token(self, user_id: int, expires_delta: Optional[timedelta] = None) -&gt; Token:&#10;        token = create_access_token(user_id, expires_delta)&#10;        return Token(access_token=token, token_type=&quot;bearer&quot;)&#10;" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from typing import Optional, Any, Coroutine&#10;&#10;from fastapi import HTTPException, status&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;&#10;from app.core.security import create_access_token, get_password_hash, verify_password&#10;from app.models import user as user_models&#10;from app.models.schemas import Token, UserCreate&#10;from app.services.users import UserService&#10;from app.models.schemas import UserRead&#10;&#10;&#10;class AuthService:&#10;    def __init__(self, session: AsyncSession) -&gt; None:&#10;        self.user_service = UserService(session)&#10;&#10;    async def authenticate_user(self, email: str, password: str) -&gt; user_models.User:&#10;        user = await self.user_service.get_by_email(email)&#10;        if not user or not verify_password(password, user.hashed_password):&#10;            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Invalid credentials&quot;)&#10;        return user&#10;&#10;    async def register_user(self, payload: UserCreate) -&gt; UserRead:&#10;        user = await self.user_service.get_by_email(payload.email)&#10;        if user:&#10;            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=&quot;Email already registered&quot;)&#10;        hashed_password = get_password_hash(payload.password)&#10;        return await self.user_service.create_user(payload, hashed_password=hashed_password)&#10;&#10;    def generate_token(self, user_id: int, expires_delta: Optional[timedelta] = None) -&gt; Token:&#10;        token = create_access_token(user_id, expires_delta)&#10;        return Token(access_token=token, token_type=&quot;bearer&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements-dev.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements-dev.txt" />
              <option name="originalContent" value="-r backend/requirements.txt&#10;pre-commit&#10;black&#10;isort&#10;ruff&#10;" />
              <option name="updatedContent" value="-r backend/requirements.txt&#10;pre-commit&#10;black&#10;isort&#10;ruff&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>